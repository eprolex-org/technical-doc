# 06.5 `watch` et `processing`

## `Process Single File`

On va maintenant ajouter notre fonction de traitement d'un fichier dans le gestionnaire d'événement :

```cs
static void FileCreated(object sender, FileSystemEventArgs e)
{
    WriteLine($"* File created: {e.Name} - type: {e.ChangeType}");

    ProcessSingleFile(e.FullPath);
}
```

On retrouve le `FullPath` dans l'`event` : `e.FullPath`.

> Adresse racourci pour lisibilité
>
> `/Users/hukar/Documents/programmation/dotnet/FileAndDirectoryJasonRoberts/DataFile` => `..`

```bash
Watching directory: ../In

* File created: HukarText01.txt - type: Created

Begin process of ../In/HukarText01.txt
Root data path is ..

Copying ../In/HukarText01.txt to ../backup/HukarText01.txt

Moving ../In/HukarText01.txt to ../processing/HukarText01.txt

Processing text file ../processing/HukarText01.txt

Moving ../DataFile/processing/HukarText01.txt to ../complete/ad969cf2-3399-4ad9-9137-eb96bfc10782_HukarText01.complete

* File deleted: HukarText01.txt - type: Deleted
```

On voit que les `events` `Created` et `Deleted` ont été déclenchés.



On peut bien entendu traiter plusieurs fichiers en même en copiant/collant trois fichiers par exemple.

```bash
...
Moving HukarText04.txt to 29bf19eb-7fb8-4142-9081-70527d9fbd76_HukarText04.complete
* File changed: HukarText02.txt - type: Changed
* File created: HukarText02.txt - type: Created
Begin process of /Users/hukar/Documents/programmation/dotnet/FileAndDirectoryJasonRoberts/DataFile/In/HukarText02.txt
ERROR: file /Users/hukar/Documents/programmation/dotnet/FileAndDirectoryJasonRoberts/DataFile/In/HukarText02.txt does not exist.
* File deleted: HukarText02.txt - type: Deleted
* File changed: HukarText03.txt - type: Changed
...
```

Je vois qu'il y a des erreurs générées :

`ERROR: file xxx.txt does not exist`



### `File Changed`

On associe maintenant le traitement de fichier (`File Processing`) à l'événement `Changed`.

```cs
static void FileChanged(object sender, FileSystemEventArgs e)
{
    WriteLine($"* File changed: {e.Name} - type: {e.ChangeType}");

    ProcessSingleFile(e.FullPath);
}
```

Cela va déclencher plusieurs fois le traitement, on obtient plusieurs erreurs car le fichier n'existe plus.

Il faut faire attention `FileSystemWatcher` réagit au `event` de l'`OS`, plusieurs événement peuvent être déclenchés pour une action.

On doit être attentif à quel `event` on associe le traitement.

Si je modifie un fichier, le `File System` va déclencher deux `event: Changed`, je vais donc avoir une erreur :

```bash
* File changed: HukarText01.txt - type: Changed
# ...

Moving HukarText01 to adbd4da2-40e6-41cc-a35a-9f08bb9e3a66_HukarText01

* File changed: HukarText01.txt - type: Changed
Begin process of HukarText01

HUK-ERROR: file HukarText01 does not exist.

* File deleted: HukarText01.txt - type: Deleted
```



## Utilisation d'un `ConcurrentDictionary`

Un `ConcurrentDictionary` est `Thread safe` `dictionary` que plusieurs `thread` peuvent accéder en même temps si pluseiurs fichiers sont traités en même temps.

> Un `Dictionary` ne peut pas contenir deux fois la même information (valeur), on va donc l'utiliser pour éviter les traîtements en double.

```cs
ConcurrentDictionary<string, string> filesDictionary = new();

// ...

void FileCreated(object sender, FileSystemEventArgs e)
{
    WriteLine($"* File created: {e.Name} - type: {e.ChangeType}");

    filesDictionary.TryAdd(e.FullPath, e.FullPath);
}

void FileChanged(object sender, FileSystemEventArgs e)
{
    WriteLine($"* File changed: {e.Name} - type: {e.ChangeType}");

    filesDictionary.TryAdd(e.FullPath, e.FullPath);
}

// ...
```

```cs
void ProcessFiles()
{
    foreach(var fileName in filesDictionary.Keys)
    {
        if(filesDictionary.TryRemove(fileName, out _))
        {
            var fileProcessor = new FileProcessor(fileName);
            fileProcessor.Process();
        }
    }
}
```

Ainsi si le fichier existe, il est retiré du `Dictionary` et est traité (`fileProcessor.Process()`)

> ### `ConcurrentDictionnary.TryRemove`
>
> ```cs
> concurrentDictionary.TryRemove(string Key, out string value)
> ```
>
> La méthode `TryRemove` retourne un booléen `true` si la paire est bien trouvée et supprimée.
>
> On peut récupérer la `value` grâce au mot clé `out`.
>
> Si on ne désire pas récupérer la valeur supprimée, on utilise `_` :
>
> ```cs
> concurrentDictionary.TryRemove(string Key, out string _)
> ```



### Utilisation d'un `Timer` pour lancer `ProcessFiles`

```cs
using Timer timer = new(ProcessFiles,null, 0, 1000);
```

On doit modifier `ProcessFiles` pour qu'il soit un paramètre valide de type `TimerCallback` :

```cs
void ProcessFiles(object? stateInfo)
{
    // ...
```

```bash
# ...
* File deleted: HukarText01.txt - type: Deleted
Begin process of HukarText01

HUK-ERROR: file HukarText01 does not exist.
```

J'ai un bug car un événement `Changed` est déclenché avant que l'événement `Deleted` ne le soit.

Le nom de mon fichier est donc remis dans le `dictionary`, je dois l'enlever dans l'événement `Deleted`.

```cs
void FileDeleted(object sender, FileSystemEventArgs e)
{
    WriteLine($"* File deleted: {e.Name} - type: {e.ChangeType}");
    FilesToProcess.Files.TryRemove(e.FullPath, out _);
}
```

Cela résout le bug.

```bash
# ...

Moving HukarText01 to 4707598c-23b7-4c30-949c-402b548669fc_HukarText01

* File changed: HukarText01.txt - type: Changed
* File deleted: HukarText01.txt - type: Deleted
```



## Utiliser le `MemoryCache` plutôt que le `Dictionary`

On ajoute le package

```
System.Runtime.Caching
```

Et on remplace `filesDictionary` par `filesCache` :

```cs
// ConcurrentDictionary<string, string> filesDictionary = new();
MemoryCache filesCache = MemoryCache.Default;
```

