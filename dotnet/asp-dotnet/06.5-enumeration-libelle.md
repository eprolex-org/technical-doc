# 06.5 Enumeration Libelle

## Implémentation pour `Eprolex`

## Version corrigée et simplifiée pour Blazor





## Version complète mais problème avec `Blazor`

### `abstract EnumerationLibelle`

```cs
using System.Reflection;

namespace Domain.Common;

public abstract class EnumerationLibelle<T> : IEquatable<EnumerationLibelle<T>>
where T : EnumerationLibelle<T>
{
public string Code { get; }
private string LibelleFr { get; }
private string LibelleNl { get; }
private string LibelleDe { get; }
private int NumeroOrdre { get; }

public static readonly Dictionary<string, T> Enumeration = CreateEnumeration();

protected EnumerationLibelle(string code, string libelleFr, string libelleNl, string libelleDe, int numeroOrdre)
{
    Code = code;
    LibelleFr = libelleFr;
    LibelleNl = libelleNl;
    LibelleDe = libelleDe;
    NumeroOrdre = numeroOrdre;
}

public string GetLibelleForCurrentCulture()
    => CultureInfo.CurrentCulture.Name switch
    {
        "fr" => LibelleFr,
        "nl" => LibelleNl,
        "de" => LibelleDe,
        _ => LibelleFr
    };

public static T GetByCode(string code)
    => Enumeration.TryGetValue(code, out var value)
        ? value
        : throw new ArgumentException($"Code {code} doesn't exist");

public bool Equals(EnumerationLibelle<T>? other)
{
    if (ReferenceEquals(null, other)) return false;
    if (ReferenceEquals(this, other)) return true;
    return Code == other.Code
           && LibelleFr == other.LibelleFr
           && LibelleNl == other.LibelleNl
           && LibelleDe == other.LibelleDe;
}

public override bool Equals(object? obj)
    => obj is EnumerationLibelle<T> other && Equals(other);

public static bool operator ==(EnumerationLibelle<T>? left, EnumerationLibelle<T>? right)
    => left is not null && left.Equals(right);

public static bool operator !=(EnumerationLibelle<T>? left, EnumerationLibelle<T>? right)
    => !(left == right);

public override int GetHashCode()
    => (Code, LibelleFr, LibelleNl, LibelleDe).GetHashCode();

private static Dictionary<string, T> CreateEnumeration()
    => typeof(T)
        .GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly)
        .Select(f => f.GetValue(null))
        .Cast<T>()
        .OrderBy(e => e.NumeroOrdre)
        .ThenBy(e => e.Code)
        .ToDictionary(e => e.Code);
}
```

### `implémentation Délai`

```cs
namespace Domain.Entities.DataProlex.LibelleProlex;

public class Delai : EnumerationLibelle<Delai>
{
    public static readonly Delai SansDelai = new Delai(
        "SansDelai",
        "13",
        "Sans délai (nihil)",
        "Geen termijn (nihil)",
        "Sans délai (nih)",
        0,
        10
    );

    public static readonly Delai Art84_1 = new Delai(
        // ...
    );

    public static readonly Delai Art84_2 = new Delai(
        // ...
    );

    // ...tous les délais
    
    public string CodeProlex { get; }
    public int NombreJours { get; }
    
    private Delai(
        string code,
        string codeProlex,
        string libelleFr,
        string libelleNl,
        string libelleDe,
        int nombreJours,
        int numeroOrdre
    ) : base(code, libelleFr, libelleNl, libelleDe, numeroOrdre)
    {
        CodeProlex = codeProlex;
        NombreJours = nombreJours;
    }
}
```

L'avantage est qu'à part les donnée en elles-même, la classe concrète est très courte à implémenter.

Le problème de cette classe, c'est qu'avec `Blazor`, une exception `TypeInitializationException` est levée.

On peut utiliser la classe `Lazy` pour résoudre cette `Exception`, 

```cs
public static readonly Lazy<Dictionary<string, T>> Enumeration 
    = new Lazy<Dictionary<string, T>>(() => CreateEnumeration());
```

mais cela créé  une lourdeur à l'utilisation avec l'emploie systématique de `Value` :

```cs
public static T GetByCode(string code)
    => Enumeration.Value.TryGetValue(code, out var value)
```

