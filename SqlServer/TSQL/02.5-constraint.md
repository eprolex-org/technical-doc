# Syntaxe des `CONSTRAINT`

```sql
CONSTRAINT PK_Invitation PRIMARY KEY CLUSTERED ([Id] ASC),
CONSTRAINT FK_Invitation_Expediteur FOREIGN KEY ([ExpediteurId]) REFERENCES [dbo].[Utilisateur] ([Id])
```



## Pourquoi des parenthèses `([ExpediteurId])`

C’est une *syntaxe propre au DDL* (`Data Definition Language`) dans SQL Server et d’autres SGBD.



Parce qu’une contrainte (PK, FK, UNIQUE, INDEX) peut concerner :

- **une seule colonne**
- **plusieurs colonnes** (clé composée)

Donc SQL Server utilise la syntaxe :

```sql
NomTable(Col1, Col2, Col3)
```



## `PRIMARY KEY` composée (2 colonnes)

```sql
CREATE TABLE CommandeProduit
(
    CommandeId INT NOT NULL,
    ProduitId INT NOT NULL,

    CONSTRAINT PK_CommandeProduit PRIMARY KEY (CommandeId, ProduitId)
);
```

La parenthèse contient **une liste de colonnes**.



## `FOREIGN KEY` composée

```sql
FOREIGN KEY (CommandeId, ProduitId)
REFERENCES CommandeProduit(CommandeId, ProduitId)
```

Parenthèses **des deux côtés** :

- à gauche : quelles colonnes locales sont la FK
- à droite : à quelles colonnes de la table référencée



## `UNIQUE` sur plusieurs colonnes

```sql
CONSTRAINT UQ_Personne_Email UNIQUE (Email, Langue)
```



## Pourquoi ce n’est pas écrit `[Table].[Col]` ?

Dans une contrainte SQL, SQL Server **ne veut pas du format qualifié** comme dans un SELECT.

Il veut **une liste de noms de colonnes**, point.

Donc :

✔ `Utilisateur(Id)` (OK)
 ✔ `[Utilisateur]([Id])` (OK)
 ❌ `[Utilisateur].[Id]` dans une contrainte (pas accepté)



## Deux syntaxe pour les `CONSTRAINT`

### Syntaxe 1 : contrainte *inline* (directement sur la colonne)

```sql
Code NVARCHAR(20) UNIQUE
```

#### ✔ Avantages

- Plus **courte**
- Plus **rapide à écrire**
- Lisible quand il n'y a *qu’une seule colonne* concernée

#### ❌ Inconvénients

- Le nom de la contrainte est généré automatiquement par SQL Server
   (du genre : `UQ__Genre__A25C5AA7109E383F`)
- Moins pratique si tu veux **normer ou nommer** toutes tes contraintes
- Ne marche **que pour une colonne unique** → impossible de faire un UNIQUE multicolonne avec cette syntaxe



### Syntaxe 2 : contrainte nommée (explicite)

```sql
CONSTRAINT UQ_Genre_Code UNIQUE ([Code])
```

#### ✔ Avantages

- Tu **choisis le nom** → meilleur pour la maintenance
- Requiert dans les entreprises utilisant des règles de nommage
- Meilleure lisibilité dans SSMS, dans les scripts de migration, etc.
- Permet les index/contraintes **sur plusieurs colonnes**
- Facile à supprimer :

```sql
ALTER TABLE Genre DROP CONSTRAINT UQ_Genre_Code;
```

#### ❌ Inconvénients

- Plus verbeux
- Une ligne séparée à écrire



















